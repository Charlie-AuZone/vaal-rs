/* automatically generated by rust-bindgen 0.66.1 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_context {
    _unused: [u8; 0],
}
#[doc = " @struct NNContext\n\n DeepViewRT Context.  Refer to the DeepviewRT User Manual for details."]
pub type NNContext = nn_context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nn_tensor {
    _unused: [u8; 0],
}
#[doc = " @struct NNTensor\n\n DeepViewRT Tensor objects.  Refer to the DeepViewRT User Manual for details."]
pub type NNTensor = nn_tensor;
#[doc = " @struct NNModel\n\n DeepviewRT Model (RTM).  Refer to the DeepViewRT User Manual for details."]
pub type NNModel = ::std::os::raw::c_void;
#[doc = " Successfull operation, no error."]
pub const VAALError_VAAL_SUCCESS: VAALError = 0;
#[doc = " Internal error without a specific error code, catch-all error."]
pub const VAALError_VAAL_ERROR_INTERNAL: VAALError = 1;
#[doc = " The provided handle is invalid.  This error is typically used by NNEngine\n when interfacing with another API"]
pub const VAALError_VAAL_ERROR_INVALID_HANDLE: VAALError = 2;
#[doc = " Out of memory error, returned if a call to malloc returns NULL or similar\n error."]
pub const VAALError_VAAL_ERROR_OUT_OF_MEMORY: VAALError = 3;
#[doc = " Out of resources errors are similar to out of memory though sometimes\n treated separately by underlying plugins."]
pub const VAALError_VAAL_ERROR_OUT_OF_RESOURCES: VAALError = 4;
#[doc = " Signals an API has not been implemented.."]
pub const VAALError_VAAL_ERROR_NOT_IMPLEMENTED: VAALError = 5;
#[doc = " A required parameter was missing or NULL or simply invalid."]
pub const VAALError_VAAL_ERROR_INVALID_PARAMETER: VAALError = 6;
#[doc = " When attempting to run an operation where the input/output tensors are\n of different types and the operation does not support automatic type\n conversions."]
pub const VAALError_VAAL_ERROR_TYPE_MISMATCH: VAALError = 7;
#[doc = " When attempting to run an operation and the input/output tensors have\n invalid or unsupported shape combinations.  Some operations require the\n shapes to be the same while others, such as arithmetic broadcasting\n operations, will support various shape combinations but if the provided\n pairs are invalid then the shape mismatch is returned."]
pub const VAALError_VAAL_ERROR_SHAPE_MISMATCH: VAALError = 8;
#[doc = " The tensor's shape is invalid for the given operation.  It differs from\n the shape mismatch in that the shape is invalid on its own and not\n relative to another related tensor.  An example would be a shape with\n more than one -1 dimension."]
pub const VAALError_VAAL_ERROR_INVALID_SHAPE: VAALError = 9;
#[doc = " The requested ordering was invalid."]
pub const VAALError_VAAL_ERROR_INVALID_ORDER: VAALError = 10;
#[doc = " The requested axis for an operation was invalid or unsupported."]
pub const VAALError_VAAL_ERROR_INVALID_AXIS: VAALError = 11;
#[doc = " A required resource was missing or the reference invalid."]
pub const VAALError_VAAL_ERROR_MISSING_RESOURCE: VAALError = 12;
#[doc = " The requested engine is invalid."]
pub const VAALError_VAAL_ERROR_INVALID_ENGINE: VAALError = 13;
#[doc = " The tensor has no data or the data is not currently accessible."]
pub const VAALError_VAAL_ERROR_TENSOR_NO_DATA: VAALError = 14;
#[doc = " The internal kernel or subroutine required to complete an operation using\n the engine plugin was missing.  An example would be OpenCL or OpenVX\n operation where the kernel implementation cannot be located."]
pub const VAALError_VAAL_ERROR_KERNEL_MISSING: VAALError = 15;
#[doc = " The operation does not support the tensor's type."]
pub const VAALError_VAAL_ERROR_TENSOR_TYPE_UNSUPPORTED: VAALError = 16;
#[doc = " For operations which can operate on an array of inputs, the provided list\n of inputs was too large."]
pub const VAALError_VAAL_ERROR_TOO_MANY_INPUTS: VAALError = 17;
#[doc = " A system error occured when interfacing with an operating system\n function.  On some systems errno might be updated with the underlying\n error code."]
pub const VAALError_VAAL_ERROR_SYSTEM_ERROR: VAALError = 18;
#[doc = " When working with a model a reference was made to a layer which did not\n exist."]
pub const VAALError_VAAL_ERROR_INVALID_LAYER: VAALError = 19;
#[doc = " The model is invalid or corrupted."]
pub const VAALError_VAAL_ERROR_MODEL_INVALID: VAALError = 20;
#[doc = " An operation referenced a model but the model was not provided."]
pub const VAALError_VAAL_ERROR_MODEL_MISSING: VAALError = 21;
#[doc = " The string was too large."]
pub const VAALError_VAAL_ERROR_STRING_TOO_LARGE: VAALError = 22;
#[doc = " The quantization parameters are invalid."]
pub const VAALError_VAAL_ERROR_INVALID_QUANT: VAALError = 23;
#[doc = " Failed to generate graph representation of model."]
pub const VAALError_VAAL_ERROR_MODEL_GRAPH_FAILED: VAALError = 24;
#[doc = " Failed to verify graph generateed from model."]
pub const VAALError_VAAL_ERROR_GRAPH_VERIFY_FAILED: VAALError = 25;
#[doc = " Unknown decoder was provided or failed to detect decoder."]
pub const VAALError_VAAL_ERROR_UNKNOWN_DECODER: VAALError = 65536;
#[doc = " Attempted to write to read-only parameter."]
pub const VAALError_VAAL_ERROR_PARAMETER_READ_ONLY: VAALError = 65537;
#[doc = " Lookup of named parameter was not found."]
pub const VAALError_VAAL_ERROR_PARAMETER_NOT_FOUND: VAALError = 65538;
#[doc = " Attempted an operation which is unsupported on the current platform."]
pub const VAALError_VAAL_ERROR_PLATFORM_UNSUPPORTED: VAALError = 65539;
#[doc = " Library has not been initialized for use, this should happen\n automatically but can be done manually using vaal_init()."]
pub const VAALError_VAAL_ERROR_LIBRARY_UNINITIALIZED: VAALError = 65540;
#[doc = " Enumeration of all errors provided by VAAL.  Most functions will return a\n VAALError with VAAL_SUCCESS being zero. A common usage pattern for client\n code is to check for err using `if (err) ...` as any error condition will\n return non-zero."]
pub type VAALError = ::std::os::raw::c_uint;
#[doc = " The VAAL_RAW type is untyped and left to the caller to handle."]
pub const VAALType_VAAL_RAW: VAALType = 0;
#[doc = " The VAAL_PTR is a standard void* pointer."]
pub const VAALType_VAAL_PTR: VAALType = 1;
#[doc = " The VAAL_FUNC is a function pointer."]
pub const VAALType_VAAL_FUNC: VAALType = 2;
#[doc = " The VAAL_STR type is a standard NULL-terminated C-string."]
pub const VAALType_VAAL_STR: VAALType = 3;
#[doc = " The VAAL_I8 type maps to a C int8_t"]
pub const VAALType_VAAL_I8: VAALType = 4;
#[doc = " The VAAL_U8 type maps to a C uint8_t"]
pub const VAALType_VAAL_U8: VAALType = 5;
#[doc = " The VAAL_I16 type maps to a C int16_t"]
pub const VAALType_VAAL_I16: VAALType = 6;
#[doc = " The VAAL_U16 type maps to a C uint16_t"]
pub const VAALType_VAAL_U16: VAALType = 7;
#[doc = " The VAAL_I32 type maps to a C int32_t"]
pub const VAALType_VAAL_I32: VAALType = 8;
#[doc = " The VAAL_U32 type maps to a C uint32_t"]
pub const VAALType_VAAL_U32: VAALType = 9;
#[doc = " The VAAL_I64 type maps to a C int64_t"]
pub const VAALType_VAAL_I64: VAALType = 10;
#[doc = " The VAAL_U64 type maps to a C uint64_t"]
pub const VAALType_VAAL_U64: VAALType = 11;
#[doc = " The VAAL_F16 type is currently unsupported but would map to either an ARM\n __fp16 or C11 (GCC extension) _Float16 type."]
pub const VAALType_VAAL_F16: VAALType = 12;
#[doc = " The VAAL_F32 type maps to a C float"]
pub const VAALType_VAAL_F32: VAALType = 13;
#[doc = " The VAAL_F64 type maps to a C double"]
pub const VAALType_VAAL_F64: VAALType = 14;
#[doc = " VAAL datatype definitions are used for identifying type information of the\n context parameters."]
pub type VAALType = ::std::os::raw::c_uint;
#[doc = " Common bounding box structure used by all decoders.  The box is defined by\n the minimum and maximum coordinates of the x,y points as normalized values.\n Normalized values are in the range 0..1 and can be multiplied by the size of\n an image to de-normalize back to actual pixel locations.\n\n The label is an index which can be used to access the textual label from the\n model or a labels file.\n\n The score's definition is model-specific but generally it is a sigmoid\n processed value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VAALBox {
    #[doc = " left-most normalized coordinate of the bounding box."]
    pub xmin: f32,
    #[doc = " top-most normalized coordinate of the bounding box."]
    pub ymin: f32,
    #[doc = " right-most normalized coordinate of the bounding box."]
    pub xmax: f32,
    #[doc = " bottom-most normalized coordinate of the bounding box."]
    pub ymax: f32,
    #[doc = " model-specific score for this detection, higher implies more confidence."]
    pub score: f32,
    #[doc = " label index for this detection, text representation can be retrived using\n @ref VAALContext::vaal_label()"]
    pub label: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_VAALBox() {
    const UNINIT: ::std::mem::MaybeUninit<VAALBox> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VAALBox>(),
        24usize,
        concat!("Size of: ", stringify!(VAALBox))
    );
    assert_eq!(
        ::std::mem::align_of::<VAALBox>(),
        4usize,
        concat!("Alignment of ", stringify!(VAALBox))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VAALBox),
            "::",
            stringify!(xmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ymin) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VAALBox),
            "::",
            stringify!(ymin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmax) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VAALBox),
            "::",
            stringify!(xmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ymax) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VAALBox),
            "::",
            stringify!(ymax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).score) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VAALBox),
            "::",
            stringify!(score)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VAALBox),
            "::",
            stringify!(label)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vaal_context {
    _unused: [u8; 0],
}
#[doc = " @struct VAALContext\n\n Context object for VAAL to manage internal model data structures.  The\n VAALContext manages the DeepViewRT NNContext as well as parameters related\n to model post-processing.\n\n Models typically require further post-processing before the outputs are\n ready to be interpreted.  What post-processing is required varies greatly\n between various model architectures. A common post-processing step is the\n decoder which is responsible for translating an internal model representation\n into one which represents the problem space.\n\n For detection models the post-processing includes the box decoding step which\n can either be integrated into the model or run as a separate step using the\n model's outputs followed by sorting and non-maximum supression \"NMS\" which is\n tasked with cleaning the bounding box output.\n\n For classification models the post-processing is typically implemented by\n finding within an output vector the index of the maximum value \"argmax\" where\n the index has meaning. For example, the index into the labels with which the\n classifier was trained. The value itself can also be interpreted as a weak\n confidence metric in cases where a softmax or sigmoid was applied to the\n vector."]
pub type VAALContext = vaal_context;
extern "C" {
    #[doc = " DeepView VAAL library version as MAJOR.MINOR.PATCH.  The library returns\n a string encoding the version and also optionally sets the provided\n arguments.\n\n @return library version string\n\n @since 1.0"]
    pub fn vaal_version(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        patch: *mut ::std::os::raw::c_int,
        extra: *mut *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " DeepView VAAL string encoding of error enum\n\n @return error string\n\n @since 1.0"]
    pub fn vaal_strerror(error: VAALError) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the size of the @ref VAALType in bytes.  Note that VAAL parameters\n can be arrays of types, so a full buffer would be length * vaal_type_sizeof.\n\n @returns element size of the @ref VAALType.\n\n @since 1.1"]
    pub fn vaal_type_sizeof(type_: VAALType) -> usize;
}
extern "C" {
    #[doc = " Returns the string name for the @ref VAALType.\n\n @param type to be returned as a string name.\n\n @returns string representation of the type.\n\n @since 1.1"]
    pub fn vaal_type_name(type_: VAALType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the current monotonic time in nanoseconds.\n\n @return monotonic time as nanoseconds\n\n @since 1.0"]
    pub fn vaal_clock_now() -> i64;
}
extern "C" {
    #[doc = " Creates a VAALContext for the provided device.  A context can manage a single\n model but many contexts can be created within an application.  If device is\n NULL then the default DeepViewRT engine will be used which evaluates models\n on the CPU.\n\n The device string can be further extended to specify device details such as\n using \"gpu:1\" to use the second GPU instead of the default one.  Refer to the\n VAAL_DEVICE documentation for details on the extended parameters.\n\n Supported devices:\n  - @ref VAAL_DEVICE_CPU\n  - @ref VAAL_DEVICE_GPU\n  - @ref VAAL_DEVICE_NPU\n\n @param device\n\n @return VAALContext\n\n @since 1.0"]
    pub fn vaal_context_create(device: *const ::std::os::raw::c_char) -> *mut VAALContext;
}
extern "C" {
    #[doc = " Releases the VAALContext unloading models and releasing any data structures\n under the control of the context.\n\n\n @since 1.0"]
    pub fn vaal_context_release(context: *mut VAALContext);
}
extern "C" {
    #[doc = " Retrieves the DeepViewRT NNContext associated with the VAALContext.  This can\n be used to further query the underlying NNEngine, NNModel, and other\n DeepViewRT API.\n\n @param context\n\n @return NNContext\n\n @since 1.0"]
    pub fn vaal_context_deepviewrt(context: *mut VAALContext) -> *mut NNContext;
}
extern "C" {
    #[doc = " Retrieves the cache tensor associated with VAAL context.\n Cache is used for post-processing and CPU inference\n\n @param context\n\n @return NNTensor\n\n @since 1.0"]
    pub fn vaal_context_cache(context: *mut VAALContext) -> *mut NNTensor;
}
extern "C" {
    #[doc = " Retrieves the dictionary data struct associated with the VAALContext.\n\n @param context\n\n @return NNContext\n @private\n @since 1.0"]
    pub fn vaal_context_dict(context: *mut VAALContext) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Retrieves the model associated with the VAALContext.\n\n @param context\n\n @return NNContext\n\n @since 1.0"]
    pub fn vaal_context_model(context: *mut VAALContext) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Queries the number of available parameters in the current context.  The count\n can be used along with @vaal_parameter_name() to query the names of the\n parameters.\n\n You should have a model loaded using @ref vaal_load_model before calling this\n function to ensure all available parameters are provided.\n\n The available parameters vary depending on model and target harwdware as\n documented in the VAAL User's Manual (TODO: need to document parameters).\n\n @return number of currently available parameters for the context.\n\n @since 1.1"]
    pub fn vaal_parameter_count(context: *mut VAALContext) -> usize;
}
extern "C" {
    #[doc = " Queries the names of parameters according to the index.  Note the indices\n are not deterministic and will vary depending on the state of the context.\n This function is meant to be used to lookup currently available parameter\n names.\n\n @return VAALError\n\n @since 1.1"]
    pub fn vaal_parameter_name(
        context: *mut VAALContext,
        index: usize,
        name: *mut ::std::os::raw::c_char,
        max_name: usize,
        name_length: *mut usize,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Queries the parameter for information about the type, length, and mutability.\n\n @param context\n @param name Parameter name as found using @ref vaal_parameter_query\n @param type Optional pointer to receive the parameter data type.\n @param length Optional pointer to receive the length of the parameter. The\n               length is measured in number of elements.  The total length can\n               be calculated by multiplying with @ref vaal_type_sizeof().\n @param readonly Optional pointer to receive the mutability of the parameter.\n                 If readonly=1 then the parameter is immutable and attempts to\n                 set a new value will return the error code\n                 @ref VAAL_ERROR_PARAMETER_READ_ONLY.\n\n @return VAALType\n\n @since 1.1"]
    pub fn vaal_parameter_info(
        context: *mut VAALContext,
        name: *const ::std::os::raw::c_char,
        type_: *mut VAALType,
        length: *mut usize,
        readonly: *mut ::std::os::raw::c_int,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Reads the current value as a string for the parameter into the user provided\n string buffer.  It can be called with max_value of 0 or value of NULL to\n query the required storage size.  If length is non-NULL then the total size\n of the string representation will be stored, even if the actual result was\n truncated.\n\n @param context\n @param name Parameter name as found using @ref vaal_parameter_query\n @param value Buffer to receive the string representation of the value\n @param max_value Size of the value buffer\n @param length Total length of the string representation of the value\n\n @return VAALError\n\n @since 1.0"]
    pub fn vaal_parameter_gets(
        context: *mut VAALContext,
        name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
        max_value: usize,
        length: *mut usize,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Writes the provided value into the parameter.  The value is provided as a\n string representation.\n\n @param context\n @param name Parameter name as found using @ref vaal_parameter_query\n @param value String representation of the new value for the parameter\n @param length Optional length of string, if left out will use strlen(value)+1\n\n @return VAALError\n\n @since 1.0"]
    pub fn vaal_parameter_sets(
        context: *mut VAALContext,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        length: usize,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Read the float values for a given \"name\" key in the context. It can be a\n scalar value or an array.\n\n @param context\n @param name Parameter name as found using @ref vaal_parameter_query\n @param values pointer to the returned float value(s)\n @param max_values length of the values array\n @param num_values number of actual values in the parameter\n\n @return VAALError\n\n @since 1.0"]
    pub fn vaal_parameter_getf(
        context: *mut VAALContext,
        name: *const ::std::os::raw::c_char,
        values: *mut f32,
        max_values: usize,
        num_values: *mut usize,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Writes the provided value into the parameter.  The value is provided as a\n float array representation.\n\n @param context\n @param name Parameter name as found using @ref vaal_parameter_query\n @param values address of the first float value\n @param num_values length of the input float array\n\n @return VAALError\n\n @since 1.0"]
    pub fn vaal_parameter_setf(
        context: *mut VAALContext,
        name: *const ::std::os::raw::c_char,
        values: *const f32,
        num_values: usize,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Read the int values for a given \"name\" key in the context. It can be a\n scalar or an array.\n\n @param context\n @param name Parameter name as found using @ref vaal_parameter_query\n @param values pointer to the returned int values\n @param max_values size of the values array\n @param num_values number of actual values in the parameter\n\n @return VAALError\n\n @since 1.0"]
    pub fn vaal_parameter_geti(
        context: *mut VAALContext,
        name: *const ::std::os::raw::c_char,
        values: *mut i32,
        max_values: usize,
        num_values: *mut usize,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Writes the provided value into the parameter.  The value is provided as a\n int array representation.\n\n @param context\n @param name Parameter name as found using @ref vaal_parameter_query\n @param value address of the first int value\n @param len length of the input int array\n\n @return VAALError\n\n @since 1.0"]
    pub fn vaal_parameter_seti(
        context: *mut VAALContext,
        name: *const ::std::os::raw::c_char,
        values: *const i32,
        num_values: usize,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Read the int values for a given \"name\" key in the context. It can be a\n scalar or an array.\n\n @param context\n @param name Parameter name as found using @ref vaal_parameter_query\n @param values pointer to the returned uint32_t values\n @param max_salues length of the values array\n @param num_values number of actual values in the parameter\n\n @return VAALError\n\n @since 1.0"]
    pub fn vaal_parameter_getu(
        context: *mut VAALContext,
        name: *const ::std::os::raw::c_char,
        values: *mut u32,
        max_values: usize,
        num_values: *mut usize,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Writes the provided value into the parameter.  The value is provided as a\n uint32_t array representation.\n\n @param context\n @param name Parameter name as found using @ref vaal_parameter_query\n @param value address of the first int value\n @param len length of the input array\n\n @return VAALError\n\n @since 1.0"]
    pub fn vaal_parameter_setu(
        context: *mut VAALContext,
        name: *const ::std::os::raw::c_char,
        values: *const u32,
        num_values: usize,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Writes the function pointer into the context under a given key.\n\n @param context\n @param name Parameter name as found using @ref vaal_parameter_query\n @param cb_ptr function pointer\n\n @return VAALError\n\n @since 1.0"]
    pub fn vaal_parameter_set_func(
        context: *mut VAALContext,
        name: *const ::std::os::raw::c_char,
        cb_ptr: *mut ::std::os::raw::c_void,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Get the raw memory address of values given a key\n\n @param context\n @param name Parameter name as found using @ref vaal_parameter_query\n @param ptr Pointer to a void* which will receive the raw pointer to the data.\n @param length Optional pointer to size_t to receive the size of the data\n pointed to by ptr.\n\n @return VAALError\n\n @since 1.0"]
    pub fn vaal_parameter_get_raw(
        context: *mut VAALContext,
        name: *const ::std::os::raw::c_char,
        ptr: *mut *mut ::std::os::raw::c_void,
        length: *mut usize,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Loads a model into the context.  This function extends the DeepViewRT model\n loading API to add model parameters and enabling input/output acceleration.\n\n This function is a convenience around @ref vaal_load_model() to load the\n model from file into memory then calling the direct from memory function.\n\n This function will also attempt to detect the model's post-processing\n requirements such as the box decoder and assign default post-processing\n parameters.  These parameters can be adjusted using the various parameter set\n and get functions.\n\n @param context The @ref VAALContext which will own this model.\n @param filename the path to the DeepViewRT (RTM) model file.\n\n @return VAALError\n\n @since 1.1"]
    pub fn vaal_load_model_file(
        context: *mut VAALContext,
        filename: *const ::std::os::raw::c_char,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Loads a model into the context.  This function extends the DeepViewRT model\n loading API to add model parameters and enabling input/output acceleration.\n\n This function will also attempt to detect the model's post-processing\n requirements such as the box decoder and assign default post-processing\n parameters.  These parameters can be adjusted using the various parameter set\n and get functions.\n\n @param context The @ref VAALContext which will own this model.\n @param memory_size the size of the model blob.\n @param memory pointer to the start of the model blob (RTM file).\n\n @return VAALError\n\n @since 1.1"]
    pub fn vaal_load_model(
        context: *mut VAALContext,
        memory_size: usize,
        memory: *const ::std::os::raw::c_void,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Unloads the model from the current context.\n\n @param context The @ref VAALContext from which to unload the model.\n\n @return VAALError\n\n @since 1.1"]
    pub fn vaal_unload_model(context: *mut VAALContext) -> VAALError;
}
extern "C" {
    #[doc = " Runs the model loaded by the VAALContext.\n\n @param context The @ref VAALContext with a loaded model to run.\n\n @return VAALError\n\n @since 1.0"]
    pub fn vaal_run_model(context: *mut VAALContext) -> VAALError;
}
extern "C" {
    #[doc = " Loads a video frame from virtual memory into the tensor, handling any\n required conversions (such as casting to floating point, if required). The\n frame must have a stride calculated from with and a known fourcc code, for\n example YUYV would need stride to be width*2 whereas NV12 would required\n stride to be width. For planar formats each plane must be packed\n sequentially, so for NV12 the UV planes must follow immediately after the Y\n plane.\n\n @param context VAALContext which owns the model into which the video frame\n will be loaded.\n @param tensor optional DeepViewRT tensor to receive the video frame.  If NULL\n the model's first input tensor will be used.\n @param memory the virtual memory location of the frame.\n @param fourcc the fourcc code for the video frame which will be used to\n convert to the model's expected format (assumed to be RGB).\n @param width the width of the source frame, it will be resized to the target\n tensor's width.\n @param height the height of the source frame, it will be resized to the\n target tensor's height.\n @param roi optional roi which will cause the input frame to be cropped before\n resizing.\n @param proc mask of image pre-processing to apply on load.\n\n @return VAALError\n\n @since 1.1"]
    pub fn vaal_load_frame_memory(
        context: *mut VAALContext,
        tensor: *mut NNTensor,
        memory: *const ::std::os::raw::c_void,
        fourcc: u32,
        width: i32,
        height: i32,
        roi: *const i32,
        proc_: u32,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Loads a video frame from physical memory into the tensor, handling any\n required conversions (such as casting to floating point, if required). The\n frame must have a stride calculated from with and a known fourcc code, for\n example YUYV would need stride to be width*2 whereas NV12 would required\n stride to be width. For planar formats each plane must be packed\n sequentially, so for NV12 the UV planes must follow immediately after the Y\n plane.\n\n @param context VAALContext which owns the model into which the video frame\n will be loaded.\n @param tensor optional DeepViewRT tensor to receive the video frame.  If NULL\n the model's first input tensor will be used.\n @param memory the virtual memory location of the frame.\n @param fourcc the fourcc code for the video frame which will be used to\n convert to the model's expected format (assumed to be RGB).\n @param width the width of the source frame, it will be resized to the target\n tensor's width.\n @param height the height of the source frame, it will be resized to the\n target tensor's height.\n @param roi optional roi which will cause the input frame to be cropped before\n resizing.\n @param proc mask of image pre-processing to apply on load.\n\n @return VAALError\n\n @since 1.1"]
    pub fn vaal_load_frame_physical(
        context: *mut VAALContext,
        tensor: *mut NNTensor,
        physical: u64,
        fourcc: u32,
        width: i32,
        height: i32,
        roi: *const i32,
        proc_: u32,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Loads a video frame from a dmabuf video buffer into the tensor, handling any\n required conversions (such as casting to floating point, if required). The\n frame must have a stride calculated from with and a known fourcc code, for\n example YUYV would need stride to be width*2 whereas NV12 would required\n stride to be width. For planar formats each plane must be packed\n sequentially, so for NV12 the UV planes must follow immediately after the Y\n plane.\n\n @param context VAALContext which owns the model into which the video frame\n will be loaded.\n @param tensor optional DeepViewRT tensor to receive the video frame.  If NULL\n the model's first input tensor will be used.\n @param dmabuf file descriptor to a dmabuf holding the video frame.\n @param fourcc the fourcc code for the video frame which will be used to\n convert to the model's expected format (assumed to be RGB).\n @param width the width of the source frame, it will be resized to the target\n tensor's width.\n @param height the height of the source frame, it will be resized to the\n target tensor's height.\n @param roi optional roi which will cause the input frame to be cropped before\n resizing.\n @param proc mask of image pre-processing to apply on load.\n\n @return VAALError\n\n @since 1.1"]
    pub fn vaal_load_frame_dmabuf(
        context: *mut VAALContext,
        tensor: *mut NNTensor,
        dmabuf: ::std::os::raw::c_int,
        fourcc: u32,
        width: i32,
        height: i32,
        roi: *const i32,
        proc_: u32,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Convenience around the @ref vaal_load_frame_memory() function which will\n first decode the image into a raw buffer.  Once the image has been decoded it\n will be sent to the load_frame function for further processing.\n\n To load an image directly from file see @ref vaal_load_image_file() instead.\n\n The following image formats are supported.\n\n - JPEG\n - PNG\n - BMP\n - TIFF\n\n @param context VAALContext which owns the model into which the video frame\n will be loaded.\n @param tensor optional DeepViewRT tensor to receive the video frame.  If NULL\n the model's first input tensor will be used.\n @param image buffer to encoded image.\n @param len size of the image buffer.\n @param roi optional roi which will cause the input frame to be cropped before\n resizing.\n @param proc mask of image pre-processing to apply on load.\n\n @return VAALError\n\n @since 1.1"]
    pub fn vaal_load_image(
        context: *mut VAALContext,
        tensor: *mut NNTensor,
        image: *const u8,
        len: usize,
        roi: *const i32,
        proc_: u32,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Convenience around the @ref vaal_load_image() function which first loads the\n image from a file.\n\n @param context VAALContext which owns the model into which the video frame\n will be loaded.\n @param tensor optional DeepViewRT tensor to receive the video frame.  If NULL\n the model's first input tensor will be used.\n @param filename path to image to be loaded.\n @param roi optional roi which will cause the input frame to be cropped before\n resizing.\n @param proc mask of image pre-processing to apply on load.\n\n @return VAALError\n\n @since 1.0"]
    pub fn vaal_load_image_file(
        context: *mut VAALContext,
        tensor: *mut NNTensor,
        filename: *const ::std::os::raw::c_char,
        roi: *const i32,
        proc_: u32,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Returns the text value for the label.  If the label is not available in the\n model then NULL will be returned.\n\n @param context The VAALContext owning the model from which we want labels.\n @param label The label index to be translated to a string.\n\n @return label string or NULL.\n\n @since 1.1"]
    pub fn vaal_label(
        context: *mut VAALContext,
        label: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Handles post-processing the model's output and reading the bounding boxes\n into the user provided array of boxes, up to @param max_boxes.  The function\n can be called with max_boxes set to 0 to cause the function to return the\n number of boxes detected, doing so causes the post-processing function to\n avoid storing the box results into @param boxes and ignoring @param max_boxes\n for early stopping.\n\n @param context The VAALContext which owns the model from which we want boxes.\n @param boxes An array of boxes which will received the decoded results.\n @param max_boxes The size of @param boxes limits the maximum number of boxes.\n @param num_boxes The number of boxes detected.\n\n @return VAALError\n\n @since 1.0"]
    pub fn vaal_boxes(
        context: *mut VAALContext,
        boxes: *mut VAALBox,
        max_boxes: usize,
        num_boxes: *mut usize,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Access the DeepViewRT NNTensor objects for the model's output.  The function\n supports multiple outputs which are selected using the index parameter.  To\n confirm the number of outputs you may use the @ref vaal_output_count()\n function and to read the names of the outputs as defined in the model file\n you may use @ref vaal_output_name().\n\n An output will fail to be found if there's no model loaded, the context is\n not valid, or the index is out of range.  It is also possible the model has\n no outputs identified.  In these cases the function will return NULL.\n\n @param context The VAALContext which owns the model from which we want to\n retrieve output tensors.\n @param index The output layer index.\n\n @return NNTensor or NULL if the output cannot be found, see notes.\n\n @since 1.1"]
    pub fn vaal_output_tensor(
        context: *mut VAALContext,
        index: ::std::os::raw::c_int,
    ) -> *mut NNTensor;
}
extern "C" {
    #[doc = " Returns the number of tensor outputs defined by the current model.  If the\n context is invalid, has no model loaded, or the model does not identify any\n outputs then the function will return 0.\n\n @param context The VAALContext which owns the model from which we want to\n count the number of outputs.\n\n @return The number of outputs defined by the model.\n\n @since 1.1"]
    pub fn vaal_output_count(context: *mut VAALContext) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the layer name from the model which corresponds to the output at the\n provided index.  If the context is invalid, has no model loaded, or the index\n is out of range then the function will return NULL.\n\n @param context The VAALContext which owns the model from which we want to get\n the output name.\n @param index the output layer index.\n\n @return The name of the layer in the model which owns the output tensor.\n\n @since 1.1"]
    pub fn vaal_output_name(
        context: *mut VAALContext,
        index: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " CenterNet decoder.\n\n @return VAALError\n\n @since 1.0"]
    pub fn vaal_postprocessing_centernet(
        heatmap_tensor: *mut NNTensor,
        regression_tensor: *mut NNTensor,
        size_tensor: *mut NNTensor,
        cache: *mut NNTensor,
        decode_out: *mut NNTensor,
    ) -> VAALError;
}
extern "C" {
    #[doc = " YOLO decoder.\n\n @return VAALError\n\n @since 1.0"]
    pub fn vaal_postprocessing_centernet_sigmoid(
        heatmap_tensor: *mut NNTensor,
        regression_tensor: *mut NNTensor,
        size_tensor: *mut NNTensor,
        cache_tensor: *mut NNTensor,
        decode_out: *mut NNTensor,
    ) -> VAALError;
}
extern "C" {
    pub fn vaal_postprocessing_yolo(
        feature_tensors: *mut *mut NNTensor,
        input_shape: ::std::os::raw::c_int,
        yolo_model_idx: ::std::os::raw::c_int,
        cache: *mut NNTensor,
        score_threshold: f32,
        iou_threshold: f32,
        max_output_size_per_class: ::std::os::raw::c_int,
        bbx_out_tensor: *mut NNTensor,
        bbx_out_dim_tensor: *mut NNTensor,
    ) -> VAALError;
}
extern "C" {
    pub fn vaal_postprocessing_nms(
        scores_tensor: *mut NNTensor,
        boxes_tensor: *mut NNTensor,
        cache_tensor: *mut NNTensor,
        score_threshold: f32,
        iou_threshold: f32,
        max_output_size_per_class: ::std::os::raw::c_int,
        bbx_out_tensor: *mut NNTensor,
        bbx_out_dim_tensor: *mut NNTensor,
    ) -> VAALError;
}
extern "C" {
    pub fn vaal_facedet_decode(
        priors: *mut NNTensor,
        loc: *mut NNTensor,
        iou: *mut NNTensor,
        conf: *mut NNTensor,
        scores: *mut NNTensor,
        boxes: *mut NNTensor,
    ) -> VAALError;
}
extern "C" {
    #[doc = " Box NMS.\n\n @return VAALError\n\n @since 1.0"]
    pub fn vaal_postprocessing_ssd_standard_bbx(
        score_tensor: *mut NNTensor,
        trans: *mut NNTensor,
        anchors: *mut NNTensor,
        cache: *mut NNTensor,
        score_threshold: f32,
        iou_threshold: f32,
        max_output_size: i32,
        bbx_out_tensor: *mut NNTensor,
        bbx_out_dim_tensor: *mut NNTensor,
    ) -> VAALError;
}
extern "C" {
    pub fn vaal_remap_detection_tensors(
        mode: *mut NNModel,
        context: *mut NNContext,
        detection_tensors: *mut *mut NNTensor,
    ) -> VAALError;
}
extern "C" {
    pub fn vaal_set_class_filter(
        decode_out: *mut NNTensor,
        class_idx_array: *mut ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    ) -> VAALError;
}
extern "C" {
    pub fn vaal_set_nms_type(
        decode_out: *mut NNTensor,
        nms_type_in: ::std::os::raw::c_int,
    ) -> VAALError;
}
extern "C" {
    pub fn vaal_check_model_string(idx: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vaal_set_detection_model_type(
        model: *mut NNModel,
        context: *mut NNContext,
        model_type_id: ::std::os::raw::c_int,
    );
}
